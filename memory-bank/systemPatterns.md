# Bookmarko - System Patterns

## Architecture Overview

Bookmarko follows a modern client-side architecture with serverless backend components:

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   React Client   │────▶│  Cloudflare     │     │   Supabase      │
│   (Frontend)     │◀────│   Functions     │     │   (Backend)     │
└─────────────────┘     └─────────────────┘     └─────────────────┘
         │                                               ▲
         │                                               │
         └───────────────────────────────────────────────┘
```

## Frontend Architecture

### Component Structure
- **Atomic Design Pattern**: Building UI from atoms → molecules → organisms → templates → pages
- **Container-Presentation Pattern**: Separating logic from presentation components

```
src/
├── components/         # Reusable UI components (atoms, molecules, organisms)
├── hooks/              # Custom React hooks for shared logic
├── lib/                # Utilities, helpers, and type definitions
├── pages/              # Page components (templates with routing)
└── main.tsx            # Application entry point
```

### State Management
- **Server State**: React Query for API data fetching, caching, and synchronization
- **Auth State**: Context API with Supabase Auth integration
- **Form State**: React Hook Form for local form state management

### Data Flow
1. Components use custom hooks to interact with data
2. Hooks handle API calls via React Query or direct Supabase calls
3. UI updates automatically based on query states (loading, error, success)

## Backend Architecture

### Database Design
- **Schema**: Relational PostgreSQL database with auth, profiles, bookmarks, tags, and bookmark_tags tables
- **Tag Management**: Tags are normalized in a dedicated `tags` table with a many-to-many relationship through `bookmark_tags`. The `tags TEXT[]` column in `bookmarks` has been deprecated and replaced by this normalized schema. All tag associations are now managed via the `bookmark_tags` join table, supporting efficient tag suggestions and queries.
- **Access Control**: Row-Level Security (RLS) for user data isolation
- **Relationships**: Foreign key constraints between users and their data, and between bookmarks and tags

### API Layer
- **RESTful Endpoints**: Automatically generated by Supabase
- **Authentication**: JWT-based auth handled by Supabase Auth
- **Data Validation**: Server-side constraints and client-side Zod validation
- **Tag Management Logic**: API endpoints and client logic now support tag creation, association, and suggestion using the normalized schema. Tag operations (add, update, fetch) are handled via dedicated service functions and Supabase queries.

### Serverless Functions
- **Metadata Extraction**: Deployed as Supabase Edge Function (previously Cloudflare Function; now standardized on Supabase Edge Functions for all environments)
- **Fallback Mechanism**: Multi-tier fallback system for robustness

## Core Code Patterns

### Authentication Flow
```typescript
// Sign up
const { data, error } = await supabase.auth.signUp({
  email,
  password,
  options: { emailRedirectTo: window.location.origin }
});

// Sign in
const { data, error } = await supabase.auth.signInWithPassword({
  email,
  password
});

// Sign out
const { error } = await supabase.auth.signOut();
```

### Data Fetching
```typescript
// React Query hook pattern
export function useBookmarks() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['bookmarks'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('bookmarks')
        .select('*');
      
      if (error) throw error;
      return data;
    }
  });
  
  // Additional mutation methods...
  
  return { bookmarks: data, isLoading, error, /* mutations */ };
}
```

### Form Handling
```typescript
// Form with Zod validation
const formSchema = z.object({
  email: z.string().email(),
  password: z.string().min(6)
});

const form = useForm({
  resolver: zodResolver(formSchema),
  defaultValues: { email: '', password: '' }
});

const onSubmit = (data) => {
  // Handle submission
};
```

## Error Handling

### Client-Side
- React Query error states for API failures
- Form validation errors with clear user feedback
- Fallback UI components when data loading fails

### Server-Side
- Graceful error responses from Supabase
- Multi-tier fallback strategy for metadata extraction
- Detailed error logging for debugging

## Security Patterns

### Authentication Security
- Email verification workflow
- JWT token-based session management
- Automatic token refresh

### Data Security
- Row-Level Security (RLS) policies
- Prepared statements to prevent SQL injection
- Input validation before database operations

### API Security
- CORS protection
- Rate limiting
- Request validation

## Testing Strategy
- **Primary Approach**: End-to-End (E2E) testing using Playwright.
- **Scope**: Cover critical user flows such as authentication, bookmark CRUD operations (Create, Read, Update, Delete), tagging, and search functionality for both the web application and the Chrome extension.
- **Organization**: Tests are located in the root `tests/` directory, organized by feature (e.g., `auth.spec.ts`, `bookmarks.spec.ts`).
- **Pattern**: Aim to use the Page Object Model (POM) pattern for better test maintainability as the suite grows. 